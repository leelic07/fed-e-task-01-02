### 1. 函数是第一公民
> 函数可以存储在变量中

> 函数可以作为参数

> 函数可以作为返回值

> 可以通过new Function()的方式来构建一个新的函数

### 2. 高阶函数
> 可以把函数作为参数传递给另一个函数

> 可以把函数作为另一个函数的返回结果
```
// once 
function once (fn) {
  let done = false
  return function () {
    if (!done) {
      done = true
      fn.apply(this, arguments)
    }
  }
}

const pay = once(function (money) { console.log(`支付了：${money}`) })

pay(5)
pay(5)
pay(5)
```
> 只会执行一次的函数

### 3. 高阶函数的意义
> 抽象可以帮我们屏蔽细节，只需要关注于我们的目标

> 高阶函数是用来抽象通用的问题

### 4. 常用的高阶函数
```
// map
const map = (array, fn) => {
  const results = []
  for (const item of array) {
    results.push(fn(item))
  }
  return results
}

let arr = [ 1, 2, 3, 4 ]
console.log(map(arr, v => v * v))

// every
const every = (array, fn) => {
  let result = true
  for (const item of array) {
    result = fn(item)
    if (!result) break
  }
  return result
}

let ar = [ 11, 12, 13 ]
console.log(every(ar, v => v > 10))

// some
const some = (array, fn) => {
  let result = false
  for (const item of array) {
    result = fn(item)
    if (result) break
  }
  return result
}

let a = [ 1, 3, 4, 9 ]
console.log(some(a, v => v % 2 === 0))
```

### 5. 闭包
> 函数和其周围的状态的引用捆绑在一起形成闭包。

> 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。

> 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕的时候会从栈上移除，但是因为堆栈上的成员被外部引用而不能释放，因此内部函数依然可以访问外部函数的成员。

### 6. 纯函数
> 相同的输入永远得到相同的输出，而且没有任何可观察的副作用。

> 纯函数类似数学中的函数，用来描述输入和输出之间的关系,y=f(x)

### 7. lodash
> first / last / toUpper / reverse / each / find / findIndex

> lodash中的函数都是纯函数
```
const _ = require('lodash')
const { log } = console

const array = [ 'jack', 'tom', 'lucy', 'kate' ]

log(_.first(array))
log(_.last(array))
log(_.toUpper(_.first(array)))
log(_.reverse(array))

const result = _.each(array, (item, index) => {
  log(item, index)
})

log(result)
```

### 8. 纯函数的好处
> 可缓存：因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来
```
const { log } = console

// 计算圆的面积
function getArea (r) {
  console.log(r)
  return Math.PI * r * r
}

const memoize = function (fn) {
  const cache = {}
  return function () {
    const key = JSON.stringify(arguments)
    cache[ key ] = cache[ key ] || fn.apply(fn, arguments) // 如果cache中有对应参数的缓存，直接返回缓存中的值。否则返回函数的执行结果
    return cache[ key ]
  }
}

const getAreaWithMemory = memoize(getArea)

log(getAreaWithMemory(4))
log(getAreaWithMemory(4))
log(getAreaWithMemory(4))
```

> 可测试：纯函数让测试更加地方便。

> 并行处理：在多线程下并行操作共享地内存数据很可能会出现以外情况。纯函数不需要访问共享地内存数据，只和传入的参数有关，所以在并行环境下可以任意运行纯函数(web worker)。

### 9. 副作用
> 副作用让一个函数变得不纯，纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。

> 副作用的来源：全局变量 / 配置文件 / 数据库 / 获取用户的输入

> 所有的外部交互都可能带来副作用，副作用使得方法的通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用是不可能完全禁止的。尽可能控制它们在可控范围内发生。

### 10. 柯里化
> 当一个函数有多个参数的时候先传递一部分参数调用它（这些参数以后永远不变），然后返回一个新的函数接受剩余的参数，返回结果。